use iso8601_timestamp::Timestamp;
use serde::Deserialize;
use std::collections::{HashMap, HashSet};

use crate::{attachment::Attachment, embed::Embed};

#[allow(dead_code)]
fn if_false(t: &bool) -> bool {
    !t
}

/// Channel message
#[derive(Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct Message {
    /// Unique message ID
    #[serde(rename = "_id")]
    pub id: String,

    /// Unique value generated by client sending this message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nonce: Option<String>,

    /// ID of the channel this message was sent in
    pub channel: String,

    /// ID of the user that sent this message
    pub author: String,

    /// Message content
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content: Option<String>,

    /// System message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub system: Option<SystemMessage>,

    /// Array of attachments
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attachments: Option<Vec<Attachment>>,

    /// Time at which this message was last edited
    #[serde(skip_serializing_if = "Option::is_none")]
    pub edited: Option<Timestamp>,

    /// Attached embeds to this message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embeds: Option<Vec<Embed>>,

    /// Array of user ids mentioned in this message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mentions: Option<Vec<String>>,

    /// Array of message ids this message is replying to
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replies: Option<Vec<String>>,

    /// Hashmap of emoji IDs to array of user IDs
    #[serde(skip_serializing_if = "HashMap::is_empty", default)]
    pub reactions: HashMap<String, HashSet<String>>,

    /// Information about how this message should be interacted with
    #[serde(skip_serializing_if = "Interactions::is_default", default)]
    pub interactions: Interactions,

    /// Name and / or avatar overrides for this message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub masquerade: Option<Masquerade>,
}

/// Information to guide interactions on this message
#[derive(Deserialize, Debug, Clone, Default, PartialEq, Eq)]
pub struct Interactions {
    /// Reactions which should always appear and be distinct
    #[serde(skip_serializing_if = "Option::is_none", default)]
    pub reactions: Option<HashSet<String>>,
    /// Whether reactions should be restricted to the given list
    #[serde(skip_serializing_if = "if_false", default)]
    pub restrict_reactions: bool,
}

#[derive(Deserialize, Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Masquerade {
    /// Replace the display name shown on this message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// Replace the avatar shown on this message (URL to image file)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub avatar: Option<String>,

    /// Replace the display role colour shown on this message
    ///
    /// Must have `ManageRole` permission to use
    ///
    /// This can be any valid CSS colour
    #[serde(skip_serializing_if = "Option::is_none")]
    pub colour: Option<String>,
}

/// System message type
#[derive(Deserialize, Debug, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum SystemMessage {
    Text { content: String },
    UserAdded { id: String, by: String },
    UserRemove { id: String, by: String },
    UserJoined { id: String },
    UserLeft { id: String },
    UserKicked { id: String },
    UserBanned { id: String },
    ChannelRenamed { name: String, by: String },
    ChannelDescriptionChanged { by: String },
    ChannelIconChanged { by: String },
}
